<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Guitar Chord Fingering Generator</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }

        .container {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
        }

        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.5em;
            background: linear-gradient(45deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .form-section {
            background: white;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.05);
        }

        .input-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #555;
        }

        input[type="text"], input[type="number"], select {
            width: 100%;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
            box-sizing: border-box;
            transition: all 0.3s ease;
        }

        input[type="text"]:focus, input[type="number"]:focus, select:focus {
            border-color: #764ba2;
            box-shadow: 0 0 5px rgba(118, 75, 162, 0.5);
            outline: none;
        }

        .button-group {
            display: flex;
            justify-content: space-between;
            gap: 10px;
        }

        button {
            padding: 12px 20px;
            border: none;
            border-radius: 5px;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease;
            text-transform: uppercase;
            flex-grow: 1;
        }

        #generateBtn {
            background: #667eea;
            color: white;
        }

        #generateBtn:hover {
            background: #5563d7;
            transform: translateY(-2px);
        }

        #clearBtn {
            background: #e0e0e0;
            color: #333;
        }

        #clearBtn:hover {
            background: #d0d0d0;
            transform: translateY(-2px);
        }

        .output-section {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.05);
            min-height: 200px;
        }

        .error-message {
            color: #d9534f;
            text-align: center;
            padding: 10px;
            background-color: #f2dede;
            border: 1px solid #ebccd1;
            border-radius: 4px;
        }

        .chord-diagrams {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 20px;
            margin-top: 20px;
        }

        .chord-diagram {
            display: flex;
            flex-direction: column;
            align-items: center;
            border: 1px solid #ccc;
            border-radius: 8px;
            padding: 10px;
            background-color: #fafafa;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .chord-diagram h3 {
            margin-top: 0;
            font-size: 1.2em;
            color: #333;
        }

        svg {
            border: 1px solid #eee;
            border-radius: 5px;
            background-color: #fff;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Guitar Chord Fingering Generator</h1>
        
        <div class="form-section">
            <div class="input-group">
                <label for="chordInput">Chord Notes (e.g., C E G)</label>
                <input type="text" id="chordInput" placeholder="C E G">
            </div>
            <div class="input-group">
                <label for="rootNote">Root Note (Optional)</label>
                <input type="text" id="rootNote" placeholder="C">
            </div>
            <div class="input-group">
                <label for="firstFret">First Fret</label>
                <input type="number" id="firstFret" value="1" min="0">
            </div>
            <div class="input-group">
                <label for="fretRange">Fret Range</label>
                <input type="number" id="fretRange" value="4" min="1" max="12">
            </div>
            <div class="button-group">
                <button id="generateBtn">Generate</button>
                <button id="clearBtn">Clear</button>
            </div>
        </div>
        
        <div class="output-section">
            <div id="output"></div>
        </div>
    </div>
    
    <script>
        // Constants for guitar tuning and notes
        const MAX_STRINGS = 6;
        const DEFAULT_TUNING = [4, 9, 2, 7, 11, 4]; // E A D G B E
        const NOTE_MAP = {
            'C': 0, 'C#': 1, 'Db': 1, 'D': 2, 'D#': 3, 'Eb': 3,
            'E': 4, 'F': 5, 'F#': 6, 'Gb': 6, 'G': 7, 'G#': 8,
            'Ab': 8, 'A': 9, 'A#': 10, 'Bb': 10, 'B': 11
        };
        const NOTE_NAMES = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
        const FINGER_MAP = { 1: 1, 2: 2, 3: 3, 4: 4, 5: 4, 6: 4 };

        // Enhanced SVG Renderer Class from main.js
        class GuitarSVGRenderer {
            constructor() {
                this.svgNS = "http://www.w3.org/2000/svg";
                this.defaultConfig = {
                    width: 350,
                    stringCount: 6,
                    stringSpacing: 40,
                    fretSpacing: 30,
                    margin: 20,
                    circleRadius: 10,
                    fontSize: {
                        fretNumber: 12,
                        chordLabel: 10,
                        title: 12,
                        debugInfo: 9
                    },
                    colors: {
                        fretLine: "black",
                        stringLine: "black",
                        rootNote: "#00ff00",
                        normalNote: "#000000",
                        rootText: "#000000",
                        normalText: "#ffffff",
                        debugText: "#666666"
                    }
                };
            }

            createChordSVG(marks, title, placementFret, formLength, templateId, diagramType, chordIndex, labelingInfo = null) {
                const cfg = this.defaultConfig;
                const svg = document.createElementNS(this.svgNS, "svg");

                const fretCount = formLength + 1;
                const topPadding = 30;
                const circlePadding = cfg.circleRadius;
                const baseHeight = cfg.margin * 2 + (fretCount * cfg.fretSpacing);
                const titleHeight = 30;
                const totalHeight = topPadding + circlePadding + baseHeight + titleHeight;

                svg.setAttribute("width", cfg.width);
                svg.setAttribute("height", totalHeight);

                this.drawFrets(svg, cfg, fretCount, placementFret, labelingInfo, topPadding + circlePadding);
                this.drawStrings(svg, cfg, fretCount, topPadding + circlePadding);
                this.drawMarks(svg, cfg, marks, title, diagramType, topPadding + circlePadding);
                this.drawTitle(svg, cfg, chordIndex, templateId, diagramType, placementFret, fretCount, topPadding + circlePadding);

                return svg;
            }

            drawFrets(svg, cfg, fretCount, fretStart, labelingInfo, topPadding = 0) {
                for (let i = 0; i <= fretCount; i++) {
                    const y = topPadding + cfg.margin + i * cfg.fretSpacing;
                    const line = document.createElementNS(this.svgNS, "line");
                    line.setAttribute("x1", cfg.margin);
                    line.setAttribute("x2", cfg.margin + (cfg.stringCount - 1) * cfg.stringSpacing);
                    line.setAttribute("y1", y);
                    line.setAttribute("y2", y);
                    line.setAttribute("stroke", cfg.colors.fretLine);
                    line.setAttribute("stroke-width", "2");
                    svg.appendChild(line);

                    this.drawFretLabel(svg, cfg, i, y, fretStart, labelingInfo);
                }
            }

            drawFretLabel(svg, cfg, fretIndex, yPos, fretStart, labelingInfo) {
                if (labelingInfo && !labelingInfo.isOpenChord) {
                    if (fretIndex === labelingInfo.labelPosition.diagramRow - 1) {
                        const text = document.createElementNS(this.svgNS, "text");
                        text.setAttribute("x", cfg.margin - 20);
                        text.setAttribute("y", yPos + 15);
                        text.setAttribute("font-size", cfg.fontSize.fretNumber);
                        text.textContent = labelingInfo.labelFret;
                        svg.appendChild(text);
                    }
                } else if (fretIndex === 0 && fretStart > 0 && !labelingInfo) {
                    const text = document.createElementNS(this.svgNS, "text");
                    text.setAttribute("x", cfg.margin - 20);
                    text.setAttribute("y", cfg.margin + 15);
                    text.setAttribute("font-size", cfg.fontSize.fretNumber);
                    text.textContent = fretStart.toString().padEnd(3, ' ');
                    svg.appendChild(text);
                }
            }

            drawStrings(svg, cfg, fretCount, topPadding = 0) {
                for (let i = 0; i < cfg.stringCount; i++) {
                    const x = cfg.margin + i * cfg.stringSpacing;
                    const line = document.createElementNS(this.svgNS, "line");
                    line.setAttribute("x1", x);
                    line.setAttribute("x2", x);
                    line.setAttribute("y1", topPadding + cfg.margin);
                    line.setAttribute("y2", topPadding + cfg.margin + fretCount * cfg.fretSpacing);
                    line.setAttribute("stroke", cfg.colors.stringLine);
                    line.setAttribute("stroke-width", "1");
                    svg.appendChild(line);
                }
            }

            drawMarks(svg, cfg, marks, title, diagramType, topPadding = 0) {
                if (!Array.isArray(marks)) {
                    console.error('Invalid marks array:', marks);
                    return;
                }
                marks.forEach(([string, fret, olabel]) => {
                    const label = olabel.trim();
                    if (!Number.isInteger(string) || !Number.isInteger(fret) || typeof label !== 'string') return;
                    this.drawSingleMark(svg, cfg, string, fret, label, title, topPadding);
                });
            }

            drawSingleMark(svg, cfg, string, fret, label, title, topPadding = 0) {
                const normalizedLabel = label.toLowerCase().trim();
                const openStringLabels = ["0", "o", "open"];

                if (fret === 0 && (normalizedLabel === "x" || (openStringLabels.includes(normalizedLabel) && title.includes("Fingerings")))) {
                    this.drawOpenStringMark(svg, cfg, string, normalizedLabel, title, topPadding);
                } else {
                    this.drawFrettedMark(svg, cfg, string, fret, label, title, topPadding);
                }
            }

            drawOpenStringMark(svg, cfg, string, normalizedLabel, title, topPadding = 0) {
                const text = document.createElementNS(this.svgNS, "text");
                text.setAttribute("x", cfg.margin + (string - 1) * cfg.stringSpacing);
                text.setAttribute("y", topPadding + cfg.margin - 5);
                text.setAttribute("font-size", cfg.fontSize.fretNumber);
                text.setAttribute("text-anchor", "middle");
                text.setAttribute("fill", "#000000");
                text.textContent = normalizedLabel === "x" ? "x" : "o";
                svg.appendChild(text);
            }

            drawFrettedMark(svg, cfg, string, fret, label, title, topPadding = 0) {
                const x = cfg.margin + (string - 1) * cfg.stringSpacing;
                const y = topPadding + cfg.margin + fret * cfg.fretSpacing - cfg.fretSpacing / 2;
                const isRoot = label.toLowerCase() === "r";
                const circle = document.createElementNS(this.svgNS, "circle");
                circle.setAttribute("cx", x);
                circle.setAttribute("cy", y);
                circle.setAttribute("r", cfg.circleRadius);
                circle.setAttribute("fill", isRoot ? cfg.colors.rootNote : cfg.colors.normalNote);
                svg.appendChild(circle);

                const text = document.createElementNS(this.svgNS, "text");
                text.setAttribute("x", x);
                text.setAttribute("y", y + 3);
                text.setAttribute("font-size", cfg.fontSize.chordLabel);
                text.setAttribute("text-anchor", "middle");
                text.setAttribute("fill", isRoot ? cfg.colors.rootText : cfg.colors.normalText);
                text.textContent = label;
                svg.appendChild(text);
            }

            drawTitle(svg, cfg, chordIndex, templateId, diagramType, placementFret, fretCount, topPadding = 0) {
                const titleText = document.createElementNS(this.svgNS, "text");
                titleText.setAttribute("x", cfg.margin);
                titleText.setAttribute("y", topPadding + cfg.margin + fretCount * cfg.fretSpacing + 25);
                titleText.setAttribute("font-size", cfg.fontSize.title);
                titleText.textContent = `${templateId} / ${diagramType}`;
                svg.appendChild(titleText);
            }
        }

        const svgRenderer = new GuitarSVGRenderer();

        const FretLabeler = {
            calculateFretLabeling: (chordData) => {
                const chord = chordData;
                const placementFret = chord.placement_fret;

                let rootMark = null;
                for (let mark of chord.intervals_marks) {
                    if (mark[2].trim() === 'R') {
                        rootMark = { string: mark[0], fretOffset: mark[1], interval: 'R' };
                        break;
                    }
                }
                
                const diagramRange = FretLabeler.calculateDiagramRange(chord, placementFret);
                const labelPosition = FretLabeler.calculateLabelPosition(chord, placementFret, diagramRange);

                return {
                    rootFretNumber: placementFret,
                    labelFret: placementFret.toString(),
                    diagramStartFret: diagramRange.startFret,
                    diagramEndFret: diagramRange.endFret,
                    shouldShowOpenStrings: diagramRange.startFret === 0,
                    labelPosition
                };
            },
            
            calculateDiagramRange: (chord, rootFretNumber) => {
                const diagramLength = 5;
                if (rootFretNumber <= 3) {
                    return { startFret: 0, endFret: diagramLength - 1 };
                }
                const startFret = Math.max(1, rootFretNumber - 2);
                return { startFret, endFret: startFret + diagramLength - 1 };
            },
            
            calculateLabelPosition: (chord, rootFretNumber, diagramRange) => {
                const positionInDiagram = rootFretNumber - diagramRange.startFret;
                return {
                    diagramRow: positionInDiagram + 1,
                    fretNumber: rootFretNumber,
                    displayText: rootFretNumber.toString().padStart(2, '0')
                };
            },
            
            labelChordFrets: (jsonData) => {
                const result = FretLabeler.calculateFretLabeling(jsonData);
                result.displayLabel = result.labelFret.padEnd(3, ' ');
                result.isOpenChord = result.shouldShowOpenStrings;
                return result;
            }
        };

        const fretLabeler = FretLabeler;

        // Utility functions
        function calculateInterval(root, note) {
            const intervals = ['R', 'm2', 'M2', 'm3', 'M3', 'P4', 'TT', 'P5', 'm6', 'M6', 'm7', 'M7'];
            const diff = (note - root + 12) % 12;
            return intervals[diff];
        }

        function parseChordInput(input) {
            const notes = input.split(/\s+/).map(note => NOTE_MAP[note.trim()]);
            const validNotes = notes.filter(note => note !== undefined);
            return [validNotes, validNotes.length];
        }

        function parseFingering(fingering, firstFret, rootNoteStr) {
            const marks = [];
            const notes = [];
            const intervals = [];

            const rootNoteNum = NOTE_MAP[rootNoteStr];

            for (let i = 0; i < fingering.length; i++) {
                const fret = fingering[i];
                if (fret === -1) {
                    marks.push([i + 1, 0, 'x']);
                } else if (fret === 0) {
                    const noteNum = DEFAULT_TUNING[i];
                    const noteName = NOTE_NAMES[noteNum];
                    const interval = calculateInterval(rootNoteNum, noteNum);
                    marks.push([i + 1, 0, 'o']);
                    notes.push([i + 1, 0, noteName]);
                    intervals.push([i + 1, 0, interval]);
                } else {
                    const displayFret = fret - firstFret + 1;
                    const noteNum = (DEFAULT_TUNING[i] + fret) % 12;
                    const noteName = NOTE_NAMES[noteNum];
                    const interval = calculateInterval(rootNoteNum, noteNum);

                    marks.push([i + 1, displayFret, FINGER_MAP[i + 1].toString()]);
                    notes.push([i + 1, displayFret, noteName]);
                    intervals.push([i + 1, displayFret, interval]);
                }
            }

            return {
                finger_marks: marks,
                notes_marks: notes,
                intervals_marks: intervals,
                placement_fret: firstFret,
                template: {
                    form_length: parseInt(document.getElementById('fretRange').value)
                }
            };
        }

        function generateChord() {
            const chordInput = document.getElementById('chordInput').value;
            const outputContainer = document.getElementById('output');

            if (!chordInput.trim()) {
                outputContainer.innerHTML = '<p class="error-message">Please enter at least one note.</p>';
                return;
            }

            const firstFret = parseInt(document.getElementById('firstFret').value);
            const fretRange = parseInt(document.getElementById('fretRange').value);
            const rootNoteStr = document.getElementById('rootNote').value || chordInput.split(/\s+/)[0];

            // Simplified mock fingering for demonstration.
            // In a real application, this would be a complex algorithm.
            const mockFingering = [firstFret, firstFret + 2, firstFret + 2, firstFret + 1, firstFret, firstFret];

            const chordData = parseFingering(mockFingering, firstFret, rootNoteStr);
            const labelingInfo = fretLabeler.labelChordFrets(chordData);

            outputContainer.innerHTML = '';

            const diagramsContainer = document.createElement('div');
            diagramsContainer.className = 'chord-diagrams';

            const types = [
                { marks: chordData.finger_marks, type: 'Fingerings' },
                { marks: chordData.notes_marks, type: 'Notes' },
                { marks: chordData.intervals_marks, type: 'Intervals' }
            ];

            types.forEach(diagram => {
                const div = document.createElement('div');
                div.className = 'chord-diagram';

                const svg = svgRenderer.createChordSVG(
                    diagram.marks,
                    `Fingering`,
                    chordData.placement_fret,
                    chordData.template.form_length,
                    'Generated',
                    diagram.type,
                    0,
                    labelingInfo
                );

                div.appendChild(svg);
                diagramsContainer.appendChild(div);
            });

            outputContainer.appendChild(diagramsContainer);
        }

        function clearAll() {
            document.getElementById('chordInput').value = '';
            document.getElementById('rootNote').value = '';
            document.getElementById('firstFret').value = '1';
            document.getElementById('fretRange').value = '4';
            document.getElementById('output').innerHTML = '';
        }

        function initializeApp() {
            document.getElementById('generateBtn').addEventListener('click', generateChord);
            document.getElementById('clearBtn').addEventListener('click', clearAll);
        }

        document.addEventListener('DOMContentLoaded', initializeApp);
    </script>
</body>
</html>
